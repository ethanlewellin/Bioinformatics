# -*- coding: utf-8 -*-
"""Sequence Alignment

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1D52u3mfMMY5pAiVADwtfNSEKvXn1UsAL
"""

import numpy as np

import pandas as pd

#Metrics
match_score = 5
mismatch_penalty= -4
gap_penalty = -4

semiGlobal = False #Perform SemiGlobal Alignment
local = True #Perform Local Alignment

#Sequences Manual Input: Comment out if using file input
sequence1 = 'GCTGGAAGGCAT'
sequence2 = 'GCAGAGCACG'

#Sequences File Input: Comment out if using manual input
#with open('covid.txt') as f:
#  sequence1 = f.readlines()
#  sequence1 = "".join(sequence1)
#  sequence1 = sequence1.replace("\n", "")

#with open('nanopore.txt') as g:
#  sequence2 = g.readlines()
#  sequence2 = "".join(sequence2)
#  sequence2 = sequence2.replace("\n", "")

#Make sequence 1 the smaller one
if len(sequence1) > len(sequence2):
  temp = sequence1
  sequence1 = sequence2
  sequence2 = temp

#Create Matrix
matrix = np.matrix([0]).repeat((len(sequence1)+1)*(len(sequence2)+1)).reshape(len(sequence1)+1,len(sequence2)+1)
dirMatrix = np.matrix(['-']).repeat((len(sequence1)+1)*(len(sequence2)+1)).reshape(len(sequence1)+1,len(sequence2)+1)

#initial conditions
if not (local or semiGlobal):
  for i in range(len(sequence1)+1):
    matrix[i,0] = i*gap_penalty
  for j in range(len(sequence2)+1):
    matrix[0,j] = j*gap_penalty

if semiGlobal:
  for i in range(1,len(sequence1)+1):
    dirMatrix[i,0] = 'U'

#Populate Matrix
seq1 = list('-'+sequence1)
seq2 = list('-'+sequence2)

#Loop through matrix, filling by row
for i in range(1,len(sequence1)+1):
  for j in range(1,len(sequence2)+1):
    score=[]
    dirc=[]

    #Check F(i-1,j-1)+score ("diagonal")
    if seq1[i]==seq2[j]:
      score.append(matrix[i-1,j-1]+match_score)
      dirc.append('D')
    else:
      score.append(matrix[i-1,j-1]+mismatch_penalty)
      dirc.append('D')

    #Check F(i,j-1) ("up")
    #If using local or semiglobal alignment, don't penalize the last column
    if (local or semiGlobal) and j == matrix.shape[1]-1:
      score.append(matrix[i-1,j])
    else:
      score.append(matrix[i-1,j]+gap_penalty)
    dirc.append('U')

    #Check F(i-1,j)
    #If using local or semiglobal alignment, don't penalize the last row
    if (local or semiGlobal) and i == matrix.shape[0]-1:
      score.append(matrix[i,j-1])
    else:
      score.append(matrix[i,j-1]+gap_penalty)
    dirc.append('L')

    #Record Best Score and Direction for Cell
    if local:
      score.append(0)
      dirc.append('-')

    matrix[i,j] = max(score)
    dirMatrix[i,j] = dirc[np.argmax(score)]

#Print best sequence
if local:
  i,j = np.where(matrix == matrix.max())
  i = i[0]
  j = j[0]
else:
  i = len(sequence1)
  j = len(sequence2)

#Lists to hold sequneces
r1 = []
r2 = []
rM = []

while True:
  if dirMatrix[i,j] == 'D':
    r1.append(seq1[i])
    r2.append(seq2[j])
    if seq1[i] == seq2[j]:
      rM.append('|')
    else:
      rM.append('*')
    i=i-1
    j=j-1

  elif dirMatrix[i,j] == 'L':
    r1.append('-')
    r2.append(seq2[j])
    rM.append(' ')
    j = j-1

  else:
    r1.append(seq1[i])
    r2.append('-')
    rM.append(' ')
    i = i-1

  if dirMatrix[i,j] == '-':
    break

# Remove '-'s at end of sequence for semiglobal alignment
if semiGlobal:
  while r1[0]=='-':
    r1.pop(0)
    r2.pop(0)
    rM.pop(0)

#Flip lists
r1.reverse()
r2.reverse()
rM.reverse()

#Show stuff
display(pd.DataFrame(matrix, index=seq1, columns = seq2))
print(''.join(r1))
print(''.join(rM))
print(''.join(r2))

if local:
  print("Sequence Alignment Score:", matrix.max())
else:
  print("Sequence Alignment Score:", matrix[len(sequence1),len(sequence2)])

#Print where 1st match is
rM.index('|')